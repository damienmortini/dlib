<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: element-input-connector/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: element-input-connector/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Signal from '../../../lib/util/Signal.js';

const CONNECTOR_ADD_SIGNAL = new Signal();

/**
 * Connector element used to link inputs and other connectors together
 * @attribute inputs
 * @attribute outputs
 * @example &lt;graph-connector
 *    inputs="[document.getElementById('input1'), document.getElementById('input2')]"
 *    outputs="[document.getElementById('output1'), document.getElementById('output2')]"
 * >&lt;/graph-connector>
 */
class InputConnectorElement extends HTMLElement {
  /**
   * Observed Attributes
   * @private
   * @constant {Array.&lt;String>}
   */
  static get observedAttributes() {
    return ['input', 'output', 'connected'];
  }

  /**
   * Undefined type flag
   * @readonly
   * @constant {number}
   * @default 0
   */
  static get TYPE_UNDEFINED() {
    return 0;
  }

  /**
   * Input type flag
   * @readonly
   * @constant {number}
   * @default 1
   */
  static get TYPE_INPUT() {
    return 1;
  }

  /**
   * Output type flag
   * @readonly
   * @constant {number}
   * @default 2
   */
  static get TYPE_OUTPUT() {
    return 2;
  }

  /**
   * Both type flag
   * @readonly
   * @constant {number}
   * @default 3
   */
  static get TYPE_BOTH() {
    return 3;
  }

  /**
   * @abstract
   */
  constructor() {
    super();

    this.attachShadow({ mode: 'open' }).innerHTML = `
      &lt;slot>
        &lt;style>
          :host {
            display: inline-block;
            position: relative;
            width: 1em;
            height: 1em;
            margin: 3px;
          }

          :host(:not([connected])) .inside {
            visibility: hidden;
          }

          .outside {
            stroke: currentColor;
            fill: none;
            vector-effect: non-scaling-stroke;
          }

          svg {
            width: 100%;
            height: 100%;
          }
        &lt;/style>
        &lt;svg viewBox="0 0 5 5" xmlns="http://www.w3.org/2000/svg">
          &lt;circle cx="2.5" cy="2.5" r="1" class="inside"/>
          &lt;circle cx="2.5" cy="2.5" r="2" stroke-dasharray="1 1" class="outside"/>
        &lt;/svg>
      &lt;/slot>
    `;

    this._onInputChangeBinded = this._onInputChange.bind(this);
    this._checkConnectionBinded = this._checkConnection.bind(this);

    this._inputElementInputs = new Set();
    this._connectorElementInputs = new Set();

    this._inputElementOutputs = new Set();
    this._connectorElementOutputs = new Set();

    const self = this;

    this._inputs = new class extends Set {
      add(value) {
        if (this.has(value) || self === value) {
          return this;
        }
        super.add(value);
        if (value.value !== undefined) {
          self._value = value.value;
        }
        if (value instanceof InputConnectorElement) {
          self._connectorElementInputs.add(value);
          value.outputs.add(self);
        } else {
          self._inputElementInputs.add(value);
        }
        value.addEventListener('input', self._onInputChangeBinded);
        self._updateConnectedStatus();
        if (!(value instanceof InputConnectorElement)) {
          self.dispatchEvent(new InputEvent('input'));
        }
        return this;
      }
      delete(value) {
        const returnValue = super.delete(value);
        if (!returnValue) {
          return;
        }
        value.removeEventListener('input', self._onInputChangeBinded);
        if (value instanceof InputConnectorElement) {
          self._connectorElementInputs.delete(value);
          value.outputs.delete(self);
        } else {
          self._inputElementInputs.delete(value);
        }
        self._updateConnectedStatus();
        return returnValue;
      }
      clear() {
        for (const value of this) {
          this.delete(value);
        }
      }
    };

    this._outputs = new class extends Set {
      add(value) {
        if (this.has(value) || self === value) {
          return this;
        }
        super.add(value);
        if (value instanceof InputConnectorElement) {
          if (self.value !== undefined) {
            value._value = self.value;
          }
          self._connectorElementOutputs.add(value);
          value.inputs.add(self);
          self.dispatchEvent(new CustomEvent('connected', {
            bubbles: true,
            composed: true,
            detail: {
              input: self,
              output: value,
            },
          }));
        } else {
          if (self.value !== undefined) {
            value.value = self.value;
          }
          self._inputElementOutputs.add(value);
        }
        self._updateConnectedStatus();
        if (value instanceof InputConnectorElement) {
          self.dispatchEvent(new InputEvent('input'));
        }
        return this;
      }
      delete(value) {
        const returnValue = super.delete(value);
        if (!returnValue) {
          return;
        }
        self._connectorElementOutputs.delete(value);
        self._inputElementOutputs.delete(value);
        if (value instanceof InputConnectorElement) {
          value.inputs.delete(self);
        }
        self._updateConnectedStatus();
        if (value instanceof InputConnectorElement) {
          self.dispatchEvent(new CustomEvent('disconnected', {
            bubbles: true,
            composed: true,
            detail: {
              input: self,
              output: value,
            },
          }));
        }
        return returnValue;
      }
      clear() {
        for (const value of this) {
          this.delete(value);
        }
      }
    };
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) {
      return;
    }

    switch (name) {
      case 'input':
        const inputIds = newValue.split(' ');
        for (const inputId of inputIds) {
          const input = this.getRootNode().querySelector(`#${inputId}`);
          requestAnimationFrame(() => {
            if (input instanceof InputConnectorElement) {
              return;
            }
            if (input) {
              this.inputs.add(input);
            }
          });
        }
        break;
      case 'output':
        const outputIds = newValue.split(' ');
        for (const outputId of outputIds) {
          const output = this.getRootNode().querySelector(`#${outputId}`);
          if (output) {
            requestAnimationFrame(() => {
              this.outputs.add(output);
            });
          }
        }
        break;
      case 'connected':
        if (!this.connected) {
          this._connectorElementInputs.clear();
          this._connectorElementOutputs.clear();
        }
        break;
    }
  }

  _checkConnection(connector) {
    if (!this.getAttribute('output')) {
      return;
    }
    if (this.getAttribute('output').split(' ').includes(connector.id)) {
      this.outputs.add(connector);
    }
  }

  connectedCallback() {
    CONNECTOR_ADD_SIGNAL.dispatch(this);
    CONNECTOR_ADD_SIGNAL.add(this._checkConnectionBinded);
  }

  disconnectedCallback() {
    CONNECTOR_ADD_SIGNAL.delete(this._checkConnectionBinded);
    if (this.type &amp; InputConnectorElement.TYPE_INPUT) {
      this.inputs.clear();
    }
    if (this.type &amp; InputConnectorElement.TYPE_OUTPUT) {
      this.outputs.clear();
    }
  }

  set connected(value) {
    if (value) {
      this.setAttribute('connected', '');
    } else {
      this.removeAttribute('connected');
    }
  }

  get connected() {
    return this.hasAttribute('connected');
  }

  _onInputChange(event) {
    this._value = event.target.value;
    for (const output of this.outputs) {
      if (!(output instanceof InputConnectorElement)) {
        output.value = this._value;
      }
    }
    this.dispatchEvent(new InputEvent('input'));
  }

  _updateConnectedStatus() {
    this.connected = !!this._connectorElementInputs.size || !!this._connectorElementOutputs.size;
    for (const output of this._inputElementOutputs) {
      output.disabled = this.connected;
    }
  }

  /**
   * Get current value stored in connector
   * @readonly
   */
  get value() {
    return this._value;
  }

  /**
   * Set of inputs
   * @readonly
   * @type {Set.&lt;HTMLInputElement|InputConnectorElement>}
   */
  get inputs() {
    return this._inputs;
  }

  /**
   * Set of outputs
   * @readonly
   * @type {Set.&lt;(HTMLInputElement|InputConnectorElement)>}
   */
  get outputs() {
    return this._outputs;
  }

  /**
   * Set of input elements (non connector) only
   * @readonly
   * @type {Set.&lt;HTMLInputElement>}
   */
  get inputElements() {
    return this._inputElementInputs;
  }

  /**
   * Set of output elements (non connector) only
   * @readonly
   * @type {Set.&lt;(HTMLInputElement)>}
   */
  get outputElements() {
    return this._inputElementOutputs;
  }

  /**
   * Type of connector as flag
   * @readonly
   * @type {number}
   */
  get type() {
    return +!!this._inputElementInputs.size &lt;&lt; 1 | +!!this._inputElementOutputs.size;
  }
}

export default InputConnectorElement;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="InputConnectorElement.html">InputConnectorElement</a></li><li><a href="InputConnectorLinkableElement.html">InputConnectorLinkableElement</a></li><li><a href="LottieAnimationElement.html">LottieAnimationElement</a></li><li><a href="module.exports.html">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#pause">pause</a></li><li><a href="global.html#paused">paused</a></li><li><a href="global.html#play">play</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Fri Feb 21 2020 18:10:34 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
